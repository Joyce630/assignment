<!DOCTYPE html>
<html>
<head>
    <!--meta charset="utf-8" /-->
    <title>Gamedev Canvas Workshop</title>
    <style>
    	* { padding: 0; margin: 0; } 
    	canvas { background: rgb(243, 235, 225); display: block; margin: 0 auto; }
    </style>
</head>
<body>

<canvas id="myCanvas" width="480" height="320"></canvas>





<script>
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");  //create a ctx variable to store the 2D rendering context — the tool that can be used to paint on the Canvas.
var x = canvas.width/2;    
var y = canvas.height-30;  //position: width的一半，height長度減30
//var dx = 2;
//var dy = -2;  //add a small value to x y after every frame has been drawn to make it appear that the ball is moving
var speedX = 0;
var speedY = 0;
var ballRadius = 10;
var paddleHeight = 10;   //define a controllable paddle to hit the ball
var paddleWidth = 75;
var paddleX = (canvas.width-paddleWidth)/2;  //its starting point on x axis

var playing = false;
var startButton;

/*var brickRowCount = 3;   
var brickColumnCount = 5;
var brickWidth = 75;
var brickHeight = 20;
var brickPadding = 10;
var brickOffsetTop = 30;   // some space from the left and top edge
var brickOffsetLeft = 30;*/

/*var bricks =[];                            //use array to create a "brick container"~
for (var c=0; c < brickColumnCount;c++){    // ++ means自增，將操作數的值加一. 如果放在操作數前面(++x), 則返回加一後的值; 如果放在操作數後面(x++), 則返回操作數原值,然後再將操作數加一
    bricks[c] = [];    //
    for (var r=0; r<brickRowCount; r++){
        bricks[c][r] = {x:0, y:0};   //brick rows and columns, and xy position of each brick；xy是这个数组的属性，注意写法
    }
} */    

    document.addEventListener("mousemove",mouseMoveHandler,false);
    
    function drawBall(){        //draw a ball
        ctx.beginPath();
        ctx.arc(x, y, ballRadius, 0, Math.PI*2);  //start angle and end angle (what angle to start and finish drawing the circle, in radians)
        ctx.fillStyle = "#0095DD";
        ctx.fill();
        ctx.closePath(); 
        gravity = 0.05;
        gravitySpeed = 0;
    }

    function drawPaddle(){
        ctx.beginPath();
        ctx.rect(paddleX, canvas.height-paddleHeight,paddleWidth,paddleHeight);     //the first two values specify the coordinate of the top left "x from the left and y from the top"
        ctx.fillstyle="#0095DD";
        ctx.fill();
        ctx.closePath();
    }

       


    function draw(){    //make the ball move
        ctx.clearRect(0 , 0, canvas.width, canvas.height);  //This is a rectangle and the whole area covered by it (the canvas) will be cleared off before each frame, so the moving ball wont leave a trail. 
        drawBall();  //dont forget to call drawBall here.
        drawPaddle();

        if(y + speedY < ballRadius){
        dy = -dy;  
        } else if (y + dy > canvas.height-ballRadius){       //if the ball touch the bottom of canvas... (觸底又可以分成碰到了paddle & 碰到paddle以外的地方)
            if(x >= paddleX && x <= paddleX + paddleWidth){    //"if in if"; To detect whether the paddle hit the ball (whether x is within the left and right ends of paddle)
                dy = -dy;
            }
            else {
                alert("Opps! Game Over");
                document.location.reload();  //reload the page to restart the game
                clearInterval(interval);   //needed for Chrome to end the game. facing some "browser differences"
            }
        } 

        if (x + dx > canvas.width-ballRadius || x + dx < ballRadius){   //when touching the right and left edge; || means "or", use it to merge two statement into one.
        dx=-dx;
        }

        gravitySpeed += gravity;
        x += speedX;
        y += speedY + gravitySpeed;
        //x += dx;   //+= means x=x+dx
        //y += dy;   //update x y with dx and dy on every frame so that the ball will be painted in new position
    }
     
    function mouseMoveHandler(e){
        var relativeX= e.clientX - canvas.offsetLeft;  //clientX 事件屬性返回當事件被觸發時鼠標指針相對於瀏覽器頁面（客戶區）的水平坐標; offsetLeft
        if(relativeX>0 && relativeX<canvas.width){     //if the mouse is inside the canvas...; && means "and"
        paddleX = relativeX - paddleWidth/2;}     
    }
   
    //The draw() function will be executed within setInterval every 10 miliseconds. The draw() function will be called every 10 milliseconds forever, or until we stop it.  setTimeout:只運行一次
    var interval = setInterval(draw, 10);




    






    

    
</script>

</body>
</html>